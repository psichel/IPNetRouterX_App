// IPSupport.m// IP support functions// Copyright 1996-2001 Sustainable Softworks// All Rights Reserved.#import "IPSupport.h"#import "unp.h"#import "stdbool.h"#import "kftSupport.h"//---------------------------------------------------------------------------//		¥ Get IP Address Class// ---------------------------------------------------------------------------//	Recognize traditional IP address classes (A, B, C, Multicast, etc.)////	Return//    An integer representing the address class.//    	(if greater than or equal to 8, it's also the prefix length)//    classString set to name of IP address classSInt32GetIPAddressClass( SInt32 theIPAddress, NSMutableString* classString ){SInt32	addressClass;	theIPAddress = (theIPAddress >> 24) & 0xff;	if (theIPAddress <= 126) {		addressClass = NMIPAddressClassA;		//LString::CopyPStr("\pClass A", classString);		if (classString) [classString setString:NSLocalizedString(@"Class A", @"Class A")];	} else {		if ((128 <= theIPAddress) && (theIPAddress <= 191)) {			addressClass = NMIPAddressClassB;			//LString::CopyPStr("\pClass B", classString);			if (classString) [classString setString:NSLocalizedString(@"Class B", @"Class B")];		} else {			if ((192 <= theIPAddress) && (theIPAddress <= 223)) {				addressClass = NMIPAddressClassC;				//LString::CopyPStr("\pClass C", classString);				if (classString) [classString setString:NSLocalizedString(@"Class C", @"Class C")];			} else {				if ((224 <= theIPAddress) && (theIPAddress <= 239)) {					addressClass = NMIPAddressMulticast;					//LString::CopyPStr("\pMulticast", classString);					if (classString) [classString setString:NSLocalizedString(@"Multicast", @"Multicast")];				} else {					if ((240 <= theIPAddress) && (theIPAddress <= 247)) {						addressClass = NMIPAddressReserved;						//LString::CopyPStr("\pReserved", classString);						if (classString) [classString setString:NSLocalizedString(@"Reserved", @"Reserved")];					} else {						if (127 == theIPAddress) {							addressClass = NMIPAddressLoopback;							//LString::CopyPStr("\pLoopback", classString);							if (classString) [classString setString:NSLocalizedString(@"Loopback", @"Loopback")];						} else {							addressClass = NMIPAddressBroadcast;							//LString::CopyPStr("\p ", classString);							if (classString) [classString setString:NSLocalizedString(@" ", @" ")];						}					}				}			}		}	}	return addressClass;}// ---------------------------------------------------------------------------//	¥ isIPAddress// ---------------------------------------------------------------------------// Is the passed string a dotted quad IPv4 address or hex IPv6 address?// Check last character is a digit// Return: 0=kTypeUnknown AF_INET, AF_INET6int isIPAddress(NSString* inString, u_int32_t *outAddress4, in6_addr_t *outAddress6){	int returnValue = 0;	u_int32_t   address = 0;	in6_addr_t address6;    u_int32_t   part;	char		cbuf[255];	int			len;	int			type;	int			start, i, j, outLen;    	do {		len = [inString length];		if ((len == 0) || (len >= 255)) break;		// look for first "." or ":" to distinguish IPv4 or IPv6		type = AF_INET;		NSRange range1 = [inString rangeOfString:@"."];		NSRange range2 = [inString rangeOfString:@":"];		if ( range2.length &&			((range1.length == 0) || (range2.location < range1.location)) ) type = AF_INET6;		// convert to C string for quick character access		[inString getCString:&cbuf[0] maxLength:255 encoding:NSUTF8StringEncoding];		// skip leading whitespace		for (start = 0; start < len; start++) {			if (cbuf[start] == ' ') continue;			if (cbuf[start] == ',') continue;			if (cbuf[start] == '-') continue;			if (cbuf[start] == '\t') continue;			if (cbuf[start] == '\r') continue;			break;		}		// must have a valid first segment		if (type == AF_INET) {			if ( !isDigit(cbuf[start]) ) break;				// look for IP address as dotted quad x.x.x.x			// get 1st segment of address			part = ipSegment1FromBuf(cbuf, &start, &outLen);			// allow address in decimal format			if (part > 255) {				address = part;				if (start == len) returnValue = type;				else if (cbuf[start] == ' ') returnValue = type;				break;			}			address |= part << 24;			// check if we're done			if (cbuf[start++] != '.') {  // dotted quad?				address = 0;				break;			}			// get 2nd segment of address			part = ipSegmentFromBuf(cbuf, &start, &outLen);			address |= part << 16;			// check if we're done			if (cbuf[start++] != '.') {  // dotted quad?				address = 0;				break;			}			// get 3rd segment of address			part = ipSegmentFromBuf(cbuf, &start, &outLen);			address |= part << 8;			// check if we're done			if (cbuf[start++] != '.') {  // dotted quad?				address = 0;				break;			}			// get 4th segment of address			part = ipSegmentFromBuf(cbuf, &start, &outLen);			address |= part;		} 		else if (type == AF_INET6) {			// an IPv6 address may be enclosed in []			if (cbuf[start] == '[') start++;			// confirm valid first digit or ::			if ( !isHexDigit(cbuf[start]) &&				((cbuf[start] != ':') || (cbuf[start+1] != ':'))				) break;			int count = 0;			bzero(&address6, sizeof(address6));			for (i=0; i<=7; i++) {				// if (i==5) might have a dotted quad				part = ipSegment6FromBuf(cbuf, &start, &outLen);				address6.s6_addr[2*i] = (part >> 8) & 0xFF;				address6.s6_addr[2*i+1] = part & 0xFF;				// more segments?				if (i == 7) break;				if (cbuf[start] != ':') break;				start++;	// skip :				if ((outLen == 0) && (count == 0)) {					// determine length of run						// count number of ":" remaining					j = start;					while (j<len) {						if (cbuf[j] == ':') {							count++;							j++;							continue;						}						if (!isHexDigit(cbuf[j++])) break;										}					// should be count+1 segments left					int index = 6 - count;					if (index > i) i = index;				}			}			// skip ending [] if present			if (cbuf[start] == ']') start++;		}		// make sure address ends with final digit or whitespace, otherwise treat as domain name		if (start == len) returnValue = type;		else if (cbuf[start] == ' ') returnValue = type;		else if (cbuf[start] == '-') returnValue = type;	// allow address range		else if (cbuf[start] == ',') returnValue = type;	// allow address list		else if (cbuf[start] == '/') returnValue = type;	// allow cidr	} while (false);	if (returnValue == AF_INET) {		if (outAddress4) *outAddress4 = address;	}	else if (returnValue == AF_INET6) {		if (outAddress6) memcpy(outAddress6, &address6, 16);	}	return returnValue;}// ---------------------------------------------------------------------------//	¥ prefixForMaskStr// ---------------------------------------------------------------------------// return prefix length as NSString for dotted quad net maskNSString*prefixForMaskStr(NSString* maskStr){	NSString* returnValue = nil;	u_int32_t mask;	u_int8_t prefixLen;	do {		if (!maskStr) break;		mask = ipForString(maskStr);		if (mask == 0) break;		prefixLen = FindRightBit(mask, 32);		returnValue = [NSString stringWithFormat:@"%d",prefixLen];	} while (FALSE);	return returnValue;}// ---------------------------------------------------------------------------//		¥ stringForIP// ---------------------------------------------------------------------------// Return the dotted quad string representing an integer IP addressNSString* stringForIP(u_int32_t inValue){	NSString* returnValue = nil;	char buf[32];	PSData outBuf;	int part[4];	// this is byte order safe	part[0] = inValue >> 24 & 0xFF;	part[1] = inValue >> 16 & 0xFF;	part[2] = inValue >> 8 & 0xFF;	part[3] = inValue & 0xFF;	outBuf.bytes = (u_int8_t*)buf;	outBuf.length = 0;	outBuf.bufferLength = 31;	outBuf.offset = 0;		appendInt(&outBuf, part[0]);	buf[outBuf.offset++] = '.';	appendInt(&outBuf, part[1]);	buf[outBuf.offset++] = '.';	appendInt(&outBuf, part[2]);	buf[outBuf.offset++] = '.';	appendInt(&outBuf, part[3]);		buf[outBuf.offset++] = 0;   // null terminate	returnValue = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];	return returnValue;}// ---------------------------------------------------------------------------//		¥ stringForIP6// ---------------------------------------------------------------------------// Return the IPv6 string representing a binary IP address (host byte order)// Options: kOptionDefault, kOptionExpand, kOptionUpperNSString* stringForIP6(in6_addr_t *inValue, int options){	NSString* returnValue = nil;	char buf[64];	PSData outBuf;	int segment;	int segment2;	int i;	int runState = 0;	// 0=none, 1=started, 2=done	outBuf.bytes = (u_int8_t*)buf;	outBuf.length = 0;	outBuf.bufferLength = 63;	outBuf.offset = 0;	// can't compress 0 first segment to :: unless second segment is also 0	segment2 = *(u_int16_t *)(&inValue->s6_addr[2]);		for (i=0; i<=7; i++) {		segment = inValue->s6_addr[2*i] << 8;		segment |= inValue->s6_addr[2*i+1];		if (!(options & kOptionExpand) && (segment == 0) && (i < 7)  && (runState < 2) &&			((i > 0) || (segment2 == 0))			) {			if (runState == 0) {				runState = 1;				buf[outBuf.offset++] = ':';				if (i==0) buf[outBuf.offset++] = ':';			}		}		else {			appendHexInt(&outBuf, segment, 4, options);			if (i < 7) buf[outBuf.offset++] = ':';			if (runState == 1) runState = 2;		}	}	buf[outBuf.offset++] = 0;   // null terminate	returnValue = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];	return returnValue;}// ---------------------------------------------------------------------------//		¥ bitStringForIP6// ---------------------------------------------------------------------------// Return the IPv6 bit label string representing part of a binary address (host byte order)// Bits are numberred 0-127 (network byte order), endPos = 128 // Options: kOptionDefault, kOptionExpand, kOptionUpperNSString* bitStringForIP6(in6_addr_t *inValue, int bitStart, int bitEnd, int options){	NSString* returnValue = nil;	char buf[64];	PSData outBuf;	int segment, segment2;	int segmentCount, i, k;	int bitLength;	int byteStart, bitStartOffset, bitEndOffset;		bitLength = bitEnd - bitStart;	if (bitLength <= 0) return nil;	if (bitLength > 128) bitLength = 128;	outBuf.bytes = (u_int8_t*)buf;	outBuf.length = 0;	outBuf.bufferLength = 63;	outBuf.offset = 0;		// open \[x...	buf[outBuf.offset++] = '\\';	buf[outBuf.offset++] = '[';	buf[outBuf.offset++] = 'x';		byteStart = bitStart / 8;	bitStartOffset = bitStart % 8;	bitEndOffset = bitEnd % 8;	segmentCount = bitLength/8;	if (bitLength % 8) segmentCount++;		for (i=0; i<segmentCount; i++) {		segment = inValue->s6_addr[byteStart + i];		k = i + 1;		if (bitStartOffset) {			segment <<= bitStartOffset;			if (k < 16) {				segment2 = inValue->s6_addr[byteStart + k];				if (k == segmentCount) {					segment2 &= 0xFF << (8 - bitEndOffset);				}			}			else segment2 = 0;			segment2 >>= 8 - bitStartOffset;			segment |= segment2;		}		// check if we need to output 1 or 2 digits from this segment		if ((k == segmentCount) && (bitEndOffset <= 4) && (bitEndOffset > 0)) {			appendHexInt(&outBuf, (segment >> 4), 1, options);		}		else appendHexInt(&outBuf, segment, 2, options);	}	// close /xx]	buf[outBuf.offset++] = '/';	appendInt(&outBuf, bitLength);	buf[outBuf.offset++] = ']';		buf[outBuf.offset++] = 0;   // null terminate	returnValue = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];	return returnValue;}// ---------------------------------------------------------------------------//		¥ ipForString// ---------------------------------------------------------------------------// Return the integer IP address (host byte order) for a dotted quad string// 0 if string is not a dotted quad "x.x.x.x"//// This routine is used heavily, so tries to be efficientu_int32_t ipForString(NSString* inString){	u_int32_t   address = 0;    u_int32_t   part;	char		cbuf[255];	int			len;	int			start, outLen;    	do {		len = [inString length];		if ((len == 0) || (len >= 255)) break;		// convert to C string for quick character access		[inString getCString:&cbuf[0] maxLength:255 encoding:NSUTF8StringEncoding];		// skip leading whitespace		for (start = 0; start < len; start++) {			if (cbuf[start] == ' ') continue;			if (cbuf[start] == ',') continue;			if (cbuf[start] == '-') continue;			if (cbuf[start] == '\t') continue;			if (cbuf[start] == '\r') continue;			break;		}		// get 1st segment of address		part = ipSegmentFromBuf(cbuf, &start, &outLen);		address |= part << 24;		// check if we're done		if (cbuf[start++] != '.') {  // dotted quad?			address = 0;			break;		}				// get 2nd segment of address		part = ipSegmentFromBuf(cbuf, &start, &outLen);		address |= part << 16;		// check if we're done		if (cbuf[start++] != '.') {  // dotted quad?			address = 0;			break;		}		// get 3rd segment of address		part = ipSegmentFromBuf(cbuf, &start, &outLen);		address |= part << 8;		// check if we're done		if (cbuf[start++] != '.') {  // dotted quad?			address = 0;			break;		}		// get 4th segment of address		part = ipSegmentFromBuf(cbuf, &start, &outLen);		address |= part;	} while (false);	return address;}// ---------------------------------------------------------------------------//		¥ ipOnlyString// ---------------------------------------------------------------------------// Remove CIDR prefix or other components from address stringNSString* ipOnlyString(NSString* inString){	NSString* str = inString;	NSRange range;	do {		if (!str) break;		str = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];		range = [str rangeOfString:@"/"];		if (range.length) {			str = [str substringToIndex:range.location];			break;		}		range = [str rangeOfString:@":"];		if (range.length) {			str = [str substringToIndex:range.location];			break;		}		range = [str rangeOfString:@" "];		if (range.length) {			str = [str substringToIndex:range.location];			break;		}	} while (0);	return str;}// ---------------------------------------------------------------------------//	¥ ipSegmentFromBuf// ---------------------------------------------------------------------------u_int32_t ipSegmentFromBuf(char *cbuf, int *offset, int *outLen){	u_int32_t	part;	int			start, i;	int			digit;	char		c;	start = *offset;	part = 0;		// hex?	if ((cbuf[start] == '0') && (cbuf[start+1] == 'x')) {		// hex		start += 2;		for (i=0; i<2; i++) {			if ( isHexDigit(c = cbuf[start]) ) {				start += 1;				if (c <= '9') digit = c - '0';				else if (c <= 'F') digit = c - 'A' + 10;				else digit = c - 'a' + 10;				part = part * 16 + digit;			}			else break;		}	}	else {			// decimal		for (i=0; i<3; i++) {			if ( isDigit(c = cbuf[start]) ) {				start += 1;				digit = c - '0';				part = part * 10 + digit;			}			else break;		}	}	*outLen = start - *offset;	*offset = start;	return part;}// ---------------------------------------------------------------------------//	¥ ipSegment1FromBuf// ---------------------------------------------------------------------------// allow address in decimal formatu_int32_t ipSegment1FromBuf(char *cbuf, int *offset, int *outLen){	u_int32_t	part;	int			start, i;	int			digit;	char		c;	start = *offset;	part = 0;		// hex?	if ((cbuf[start] == '0') && (cbuf[start+1] == 'x')) {		// hex		start += 2;		for (i=0; i<2; i++) {			if ( isHexDigit(c = cbuf[start]) ) {				start += 1;				if (c <= '9') digit = c - '0';				else if (c <= 'F') digit = c - 'A' + 10;				else digit = c - 'a' + 10;				part = part * 16 + digit;			}			else break;		}	}	else {			// decimal		for (i=0; i<10; i++) {			if ( isDigit(c = cbuf[start]) ) {				start += 1;				digit = c - '0';				part = part * 10 + digit;			}			else break;		}	}	*outLen = start - *offset;	*offset = start;	return part;}// ---------------------------------------------------------------------------//	¥ ipSegment6FromBuf// ---------------------------------------------------------------------------// extract IPv6 segmentu_int32_t ipSegment6FromBuf(char *cbuf, int *offset, int *outLen){	u_int32_t	part = 0;	int			start, i;	int			digit;	char		c;	do {		if (!offset) break;		start = *offset;		// hex		for (i=0; i<4; i++) {			if ( isHexDigit(c = cbuf[start]) ) {				start += 1;				if (c >= 'a') digit = 10 + c - 'a';				else if (c >= 'A') digit = 10 + c - 'A';				else digit = c - '0';				part = part * 16 + digit;			}			else break;		}		if (outLen) *outLen = start - *offset;		*offset = start;	} while (false);	return part;}// ---------------------------------------------------------------------------//		¥ stringForNetNumber// ---------------------------------------------------------------------------// return "address/prefix_len" string for integer address and maskNSString* stringForNetNumber(u_int32_t inAddress, u_int32_t inMask){	NSString* returnValue = nil;	char buf[32];	PSData outBuf;	int part[4];	part[0] = inAddress >> 24 & 0xFF;	part[1] = inAddress >> 16 & 0xFF;	part[2] = inAddress >> 8 & 0xFF;	part[3] = inAddress & 0xFF;	outBuf.bytes = (u_int8_t*)buf;	outBuf.length = 0;	outBuf.bufferLength = 31;	outBuf.offset = 0;		appendInt(&outBuf, part[0]);	buf[outBuf.offset++] = '.';	appendInt(&outBuf, part[1]);	buf[outBuf.offset++] = '.';	appendInt(&outBuf, part[2]);	buf[outBuf.offset++] = '.';	appendInt(&outBuf, part[3]);	int prefixLength = FindRightBit(inMask, 32);	if (prefixLength) {		buf[outBuf.offset++] = '/';		appendInt(&outBuf, prefixLength);	}	buf[outBuf.offset++] = 0;   // null terminate	returnValue = [NSString stringWithCString:buf encoding:NSUTF8StringEncoding];	return returnValue;}// ---------------------------------------------------------------------------//		¥ netNumberForString// ---------------------------------------------------------------------------// Return the integer address & mask (netNumber) for a dotted quad address/prefixLen string// 0 if string is invalid.  Default to prefixLen 32 if none given (IP address only).u_int32_t netNumberForString(NSString* inString, u_int32_t* outAddress, u_int32_t* outMask){	u_int32_t   address = 0;	u_int32_t   mask = 0;	int			prefixLen = 32;	NSRange range;        if (inString) {		address = ipForString(inString);		range = [inString rangeOfString:@"/"];		if (range.length) {			NSString* str;			char cbuf[4];			int digit;			int part = 0;			str = [inString substringFromIndex:range.location+range.length];			[str getCString:cbuf maxLength:3 encoding:NSUTF8StringEncoding];			if (isDigit(cbuf[0])) {				part = cbuf[0] - '0';				if (isDigit(cbuf[1])) {					digit = cbuf[1] - '0'; 					part = part * 10 + digit;				}			}			if (part <= 32) prefixLen = part;		}		mask = 0xFFFFFFFF << (32 - prefixLen);	}	if (outAddress) *outAddress = address;	if (outMask) *outMask = mask;	return address & mask;}// ---------------------------------------------------------------------------//	¥ addressForData// ---------------------------------------------------------------------------// Extract address and port from dataRef to sockaddr_in// Return address type (0 for unknown or AF_INET or AF_INET6)int addressForData(NSData* dataRef, u_int32_t* address, in6_addr_t* address6, u_int16_t* port){	int returnValue = 0;	do {		struct sockaddr_in *sin = (struct sockaddr_in *)[dataRef bytes];		if (sin && (sin->sin_family == AF_INET)) {			*address = ntohl(sin->sin_addr.s_addr);			if (port) *port = ntohs(sin->sin_port);			returnValue = AF_INET;			break;		}		struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)[dataRef bytes];		if (sin6 && (sin6->sin6_family == AF_INET6)) {			memcpy(address6, &sin6->sin6_addr, 16);			if (port) *port = ntohs(sin6->sin6_port);			returnValue = AF_INET6;			break;		}		*address = 0;		if (port) *port = 0;	} while (false);	return returnValue;}// ---------------------------------------------------------------------------//	¥ dataForAddress// ---------------------------------------------------------------------------// Convert address and port to dataRef to sockaddr_inNSData* dataForAddress(u_int32_t address, u_int16_t port){	NSMutableData *dataRef = [NSMutableData dataWithLength:16];	struct sockaddr_in *sin = (struct sockaddr_in *)[dataRef bytes];	if (sin) {		sin->sin_len = 16;		sin->sin_family = AF_INET;		sin->sin_port = htons(port);		sin->sin_addr.s_addr = htonl(address);	}	return dataRef;}// ---------------------------------------------------------------------------//	¥ dataForAddress6// ---------------------------------------------------------------------------// Convert address and port to dataRef to sockaddr_in6NSData* dataForAddress6(in6_addr_t* address6, u_int16_t port){	NSMutableData *dataRef = [NSMutableData dataWithLength:sizeof(struct sockaddr_in6)];	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)[dataRef bytes];	if (sin6) {		bzero(sin6, sizeof(struct sockaddr_in6));		sin6->sin6_len = sizeof(struct sockaddr_in6);		sin6->sin6_family = AF_INET6;		sin6->sin6_port = htons(port);		memcpy(&sin6->sin6_addr, address6, 16);	}	return dataRef;}// ---------------------------------------------------------------------------//		¥ addPercentEscapes// ---------------------------------------------------------------------------//	Encode non-printable characters as percent escapes (%XX)//  Per DHCP convention, we use the first byte as a formatting clue.//	If first byte is 1, encode entire string as hex (%XX) (for DHCP ClientID)//  If first byte is 0, skip it and display as text for DHCP ClientIDNSString* addPercentEscapes(NSData* inData){	NSString* returnValue;	u_int8_t* pi;	u_int8_t* po;	u_int8_t* limit;	char buf[255];	int c;	int len;	bool encodeFlag = false;	u_int8_t digit;	do {			po = (u_int8_t*)&buf[0];		len = 0;		pi = (u_int8_t*)[inData bytes];		if ([inData length] == 0) break;		limit = pi + [inData length];		if (*pi == 1) {			encodeFlag = true;			pi++;		}		else if (*pi == 0) pi++;		while (pi < limit) {			c = *pi++;			// check for buffer full (leave room for percent escape)			if (len >= 250) break;			if ((c <= 0x20) || (c >= 0x7F) || (c == '%') || encodeFlag) {				*po++ = '%';								digit = (c >> 4) & 0x0F;				if (digit < 10) digit += '0';				else digit += ('A' - 10);				*po++ = digit;								digit = c & 0x0F;				if (digit < 10) digit += '0';				else digit += ('A' - 10);				*po++ = digit;				len += 3;			}			else {				// handle normal printing characters				*po++ = c;				len++;			}		}	} while (false);	// add terminating null and return	*po = 0;	returnValue = [NSString stringWithUTF8String:&buf[0]];	return returnValue;}// ---------------------------------------------------------------------------//		¥ removePercentEscapes// ---------------------------------------------------------------------------//	Decode percent escapes (%XX)NSData* removePercentEscapes(NSString* inString){	NSData* returnValue = nil;	NSData* inData;	u_int8_t* pi;	u_int8_t* po;	u_int8_t* limit;	char buf[255];	int c;	int len;	u_int8_t digit;	u_int8_t byte;	do {		if (!inString) break;		inData = [inString dataUsingEncoding:NSASCIIStringEncoding];		if (![inData length]) break;		pi = (u_int8_t*)[inData bytes];		limit = pi + [inData length];		po = (u_int8_t*)&buf[0];		len = 0;		while (pi < limit) {			c = *pi++;			// check for buffer full			if (len >= 250) break;			if (c == '%') {				// 1st hex				c = *pi++;				digit = c - '0';				if (digit > 9) digit = c - 'A' + 10;				if (digit > 15) digit = (c - 'a' + 10) & 0x0F;				byte = digit << 4;				// 2nd hex				c = *pi++;				digit = c - '0';				if (digit > 9) digit = c - 'A' + 10;				if (digit > 15) digit = (c - 'a' + 10) & 0x0F;				byte |= digit;				*po++ = byte;				len++;			}			else {				// handle normal printing characters				*po++ = c;				len++;			}		}		returnValue = [NSData dataWithBytes:&buf[0] length:len];	} while (false);	return returnValue;}// ---------------------------------------------------------------------------//		¥ FindRightBit// ---------------------------------------------------------------------------//	Find right most one bit in 32 bit data.//	If found, return bit position from MSB (1) to LSB (32)//	Returns zero if not foundUInt8FindRightBit(UInt32 inData, UInt8 inStart){	UInt32	mask, index;	for (index=inStart; index>=1; index--) {		mask = (UInt32)0x01 << (32-index);		if ( (mask&inData) != 0 ) {			return index;		}	}	return 0;}// ---------------------------------------------------------------------------//		¥ FindLeftBit// ---------------------------------------------------------------------------//	Find left most one bit in 32 bit data.//	If found, return bit position from MSB (1) to LSB (32)//	Returns zero if not foundUInt8FindLeftBit(UInt32 inData, UInt8 inStart){	UInt32	mask, index;	for (index=inStart; index<=32; index++) {		mask = (UInt32)0x01 << (32-index);		if ( (mask&inData) != 0 ) {			return index;		}	}	return 0;}#define READ_BUFFER_SIZE 512// ---------------------------------------------------------------------------------//	¥ readFileHandle:data:// ---------------------------------------------------------------------------------// Wait for first byte and then use select with timeout to read upto READ_BUFFER_SIZE// or whatever is available.  Ideal for reading the piped output of UNIX network commands.//// Notice we can't wait for the entire output to become available// using "data = [standardOutputHandle availableData];"// because the command might block if there is too much unread data.//// Input: *dataP == nil, dataP != nil, a pointer to a NSData pointer// Output: <0 error or end of file, 0 timeout, >0 bytes read//  *dataP will point to an NSData containing the data read.//int readFileHandle(NSFileHandle *fileHandle, NSData **dataP){    int returnValue = -1;	int fd;	struct timeval timeout = { 0, 10 };    int bytesLeft = READ_BUFFER_SIZE;    int totalBytesRead = 0;	NSMutableData* readBuffer;    char *dataPtr;    fd_set readfds, writefds, exceptfds;	// get fd for fileHandle	fd = [fileHandle fileDescriptor];	do {		if (dataP == nil) break;		if (*dataP != nil) break;		readBuffer = [[[NSMutableData alloc] initWithLength:READ_BUFFER_SIZE] autorelease];		if (!readBuffer) break;		dataPtr = [readBuffer mutableBytes];			while (bytesLeft > 0) {			returnValue = Read( fd, dataPtr, (unsigned long)bytesLeft );			if (returnValue < 0) break;	// other read error			if (returnValue == 0) {		// end of file				returnValue = -1;				break;			}				bytesLeft -= returnValue;			dataPtr += returnValue;			totalBytesRead += returnValue;			if( bytesLeft == 0 ) break; // Stop the read if we've read them all in				// Ensure that after reading the first byte we test to see if there are			// more bytes to read so we don't block indefinitely.			FD_ZERO( &readfds );			FD_ZERO( &writefds );			FD_ZERO( &exceptfds );			FD_SET( fd, &readfds ); // We're only interested in reading bytes				returnValue = Select( fd + 1, &readfds, &writefds, &exceptfds, &timeout );			// select returns 0 for timeout			if( returnValue < 0 ) break;		// select error			if( !FD_ISSET( fd, &readfds ) ) break;	// nothing to read		}		if (totalBytesRead > 0) {			[readBuffer setLength:totalBytesRead];			*dataP =  (NSData *)readBuffer;			returnValue = totalBytesRead;		}	} while (false);    return returnValue;}