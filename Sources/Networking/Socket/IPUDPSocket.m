////  IPUDPSocket.m//  IPNetMonitorX////  Created by psichel on Mon Nov 12 2001.//  Copyright (c) 2001 Sustainable Softworks. All rights reserved.////  Encapsulate a BSD UDP Socket//  receiveFrom can block so we add a timeOut parameter that uses select//  does not encapsulate threading#import "IPUDPSocket.h"#import <sys/uio.h>		// iovec// Forward function declarationsssize_t		Sendto(int sockfd, const void *buff, size_t nbytes, int flags,                    const struct sockaddr *to, int addrlen);ssize_t		Recvfrom(int sockfd, void *buff, size_t nbytes, int flags,                    struct sockaddr *from, socklen_t *addrlen);                    @interface IPUDPSocket (PrivateMethods)- (ssize_t) receiveFrom:(IPHost *)host data:(NSMutableData *)dataBuffer    control:(NSMutableData *)controlBuffer;    // receiveFrom: can block forever so we hide it as a private method	// behind receiveFrom:withTimeOut: that uses select()@end@implementation IPUDPSocket//--Setup--- (id)init {    int socket;    socket = Socket(AF_INET, SOCK_DGRAM, 0);    self = [super initWithSocket:socket];	mCloseSocket = YES;    return self;}- (ssize_t) receiveFrom:(IPHost *)host data:(NSMutableData *)dataBuffer    control:(NSMutableData *)controlBuffer//  receiveFrom can block forever//  Assume client has set a socket time out or used select (readableTimeout).//  Could use signal to interrupt but threads share signal handlers.//  We use recvmsg instead of recvfrom to collect ancilliary data{    ssize_t result;    sockaddr_t socketAddress;    iovec_t iov[1];    struct control {        cmsghdr_t cmsg;        UInt8 data[20];    } control;    int flags = 0;    msghdr_t msg = {0};        // load msghdr    msg.msg_name = (void*)&socketAddress;    msg.msg_namelen = sizeof(socketAddress);        msg.msg_iov = iov;    msg.msg_iovlen = 1;    iov[0].iov_base = [dataBuffer mutableBytes];    iov[0].iov_len = [dataBuffer length];        msg.msg_control = (caddr_t) &control;    msg.msg_controllen = sizeof( control );    if (controlBuffer) {        msg.msg_control = (caddr_t) [controlBuffer mutableBytes];        msg.msg_controllen = [controlBuffer length];    }       memset( msg.msg_control, 0, msg.msg_controllen);        if (mSocket > 0) {	// make sure we got a valid socket        result = recvmsg(mSocket, &msg, flags);        if (result >= 0) {            if (host) [host setSocketAddress:&socketAddress size:msg.msg_namelen];            [dataBuffer setLength:result];	// set length to number of bytes read			[controlBuffer setLength:msg.msg_controllen];        }		else {			int errno_save = errno;			NSLog(@"recvmsg error %s",strerror(errno_save));		}    }    else result = mSocket;	// return the socket error we got    return result;}- (ssize_t) receiveFrom:(IPHost *)host data:(NSMutableData *)dataBuffer    control:(NSMutableData *)controlBuffer withTimeOut:(NSTimeInterval)seconds//  receiveFrom can block so we add a timeOut parameter that uses select//  does not encapsulate threading{    ssize_t result;        result = [self waitUntilReadableTimeOut:seconds];    // handle select event (<0=socket error, 0=timeout, >0=readable    if (result > 0) {        result = [self receiveFrom:host data:dataBuffer control:controlBuffer];    }    return result;}- (ssize_t) sendTo:(IPHost *)host data:(NSData *)data// returns the number of bytes sent or -1 on error// for UDP, there is no socket buffer, so this should never block{    ssize_t result;    int	flags=0;        if (mSocket > 0) {	// make sure we got a valid socket        result = Sendto(mSocket, [data bytes], [data length], flags,            [host socketAddress], [host socketAddressLen]);    }    else result = mSocket;	// return the socket error we got    return result;}@end// ---------------------------------------------------------------------------//		¥ Error checking wrappers// ---------------------------------------------------------------------------ssize_tSendto(int sockfd, const void *buff, size_t nbytes, int flags,                    const struct sockaddr *to, int addrlen){	ssize_t n;	int errno_save;		do {		n = sendto(sockfd, buff, nbytes, flags, to, addrlen);	} while ((n < 0) && (errno == EINTR));	if ( n < 0) {		errno_save = errno;		if ((errno_save != EHOSTDOWN) && (errno_save != EHOSTUNREACH)) {			NSLog(@"sendto error");			NSLog(@"%s", strerror(errno_save));							}	}	return (n);}ssize_tRecvfrom(int sockfd, void *buff, size_t nbytes, int flags,                    struct sockaddr *from, socklen_t *addrlen){	ssize_t n;	int errno_save;		do {		n = recvfrom(sockfd, buff, nbytes, flags, from, addrlen);	} while ((n < 0) && (errno == EINTR));	if ( n < 0) {		errno_save = errno;        if (errno_save == EWOULDBLOCK) n=0;        else {            NSLog(@"recvfrom error");            NSLog(@"%s", strerror(errno_save));        }					}	return (n);}