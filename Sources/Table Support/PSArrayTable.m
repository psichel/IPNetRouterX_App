//  PSArrayTable.m//  IPNetMonitorX////  Created by Peter Sichel on Mon Nov 10 2003.//  Copyright (c) 2003 Sustainable Softworks, Inc. All rights reserved.////	Delegate and data source for Array table.//  Dynamic table implemented with NSArray//  Allows fast insert and remove.#import "PSArrayTable.h"#import "PSImageString.h"#import "PSStateEntry.h"#import "PSServer.h"	// updateParameter:withObject:@implementation PSArrayTable// ---------------------------------------------------------------------------------//	¥ init// ---------------------------------------------------------------------------------- (id) init {    if (self = [super init]) {        tableArray = [[NSMutableArray alloc] init];		delegate = nil;    }    return self;}- (void)dealloc {    [tableArray release];		tableArray = nil;	[self setDelegate:nil];    [super dealloc];}// ---------------------------------------------------------------------------------//	¥ description// ---------------------------------------------------------------------------------- (NSString *)description{	return [tableArray description];}#pragma mark -- logistics --// ---------------------------------------------------------------------------------//	¥ delegate// ---------------------------------------------------------------------------------- (id)delegate { return delegate; }- (void)setDelegate:(id)value {	//[value retain];	//[delegate release];	delegate = value;}// ---------------------------------------------------------------------------------//	¥ updateTable// ---------------------------------------------------------------------------------// Notify any listeners when table data has been modified.// We don't send the whole table object here.  That kind of update is// handled by sending the table dictionary, or a message containing// a series of table entries.- (void)updateTable:(NSString *)tableName{	[delegate updateParameter:tableName withObject:tableName];}#pragma mark -- table access --// ---------------------------------------------------------------------------------//	¥ count// ---------------------------------------------------------------------------------- (unsigned)count{    return [tableArray count];}// Access table array// ---------------------------------------------------------------------------------//	¥ tableArray// ---------------------------------------------------------------------------------- (NSMutableArray *)tableArray { return tableArray; }- (void)setTableArray:(NSMutableArray *)value{	[value retain];	[tableArray release];	tableArray = value;}// ---------------------------------------------------------------------------------//	¥ arrayOfDictionaries// ---------------------------------------------------------------------------------- (NSMutableArray *)arrayOfDictionaries{	NSMutableArray* returnArray;	NSEnumerator* en;	PSStateEntry* entry;		returnArray = [[[NSMutableArray alloc] init] autorelease];	en = [tableArray objectEnumerator];	while (entry = [en nextObject]) {		[returnArray addObject:[entry nodeDictionary]];	}	return returnArray;}// ---------------------------------------------------------------------------------//	¥ loadArrayOfDictionaries:forEntryClass:// ---------------------------------------------------------------------------------// load table from dictionary of node Dictionaries creating table entries of class- (BOOL)loadArrayOfDictionaries:(NSArray *)inArray forEntryClass:(Class)class{	int returnValue = NO;	int i, count;	NSDictionary* nodeDictionary;	id entry;		[self removeAllObjects];	if (inArray) {		count = [inArray count];		for (i=0; i<count; i++) {			nodeDictionary = [inArray objectAtIndex:i];			entry = [class entryFromDictionary:nodeDictionary];			if (entry) [self addObject:entry];		}		returnValue = YES;	}	return returnValue;}	// key value coding// ---------------------------------------------------------------------------------//	¥ tableDictionary// ---------------------------------------------------------------------------------// Walk array to build dictionary for data interchange- (NSMutableDictionary *)tableDictionary{	NSMutableDictionary* td;	NSEnumerator* en;	id entry;		td = [NSMutableDictionary dictionaryWithCapacity:[tableArray count]];	en = [tableArray objectEnumerator];	while (entry = [en nextObject]) {		[td setObject:entry forKey:[entry key]];	}	return td;}- (void)setTableDictionary:(NSMutableDictionary *)value{	NSEnumerator* en;	id entry;		[self removeAllObjects];	en = [value objectEnumerator];	while (entry = [en nextObject]) {		[self setObject:entry forKey:[entry key]];	}}- (id)valueForKey:(id)key {	return [self objectForKey:key]; }	// save and restore// ---------------------------------------------------------------------------------//	¥ tableDictionaryOfDictionaries// ---------------------------------------------------------------------------------// Return as dictionary of dictionaries for export as XML- (NSDictionary *)dictionaryOfDictionaries{	NSMutableDictionary* td;	NSEnumerator* en;	id entry;		td = [NSMutableDictionary dictionaryWithCapacity:[tableArray count]];	en = [tableArray objectEnumerator];	while (entry = [en nextObject]) {		[td setObject:[entry nodeDictionary] forKey:[entry key]];	}	return td;}// ---------------------------------------------------------------------------------//	¥ loadDictionaryOfDictionaries:forEntryClass:// ---------------------------------------------------------------------------------// load table from dictionary of node Dictionaries creating table entries of class- (BOOL)loadDictionaryOfDictionaries:(NSDictionary *)inDictionary forEntryClass:(Class)class{	int returnValue = NO;	NSEnumerator* en;	NSDictionary* nodeDictionary;	id entry;		[self removeAllObjects];	if (inDictionary) {		en = [inDictionary objectEnumerator];		while (nodeDictionary = [en nextObject]) {			entry = [class entryFromDictionary:nodeDictionary];			if (entry) [self setObject:entry forKey:[entry key]];		}		returnValue = YES;	}	return returnValue;}//- Access table entries#pragma mark -- array access --// We extend the NSArray semantics to define access to entries beyond// the end of the current array.  Use kNullObject as place holder for// empty entries and return nil as their value.// ---------------------------------------------------------------------------------//	¥ objectAtIndex// ---------------------------------------------------------------------------------// get object value from Table data array for specified index.// Return nil if index is beyond end of array.- (id)objectAtIndex:(unsigned)index {    id returnValue = nil;    int count;    count = [tableArray count];    if (index < count) {        returnValue = [tableArray objectAtIndex:index];		if ([returnValue isKindOfClass:[NSString class]]) {			if ([returnValue isEqualTo:kNullObject]) returnValue = nil;		}	}    return returnValue;}// ---------------------------------------------------------------------------------//	¥ removeObjectAtIndex// ---------------------------------------------------------------------------------- (BOOL)removeObjectAtIndex:(int)index{    int count;    BOOL result = NO;    count = [tableArray count];    if (index < count) {        [tableArray removeObjectAtIndex:index];        result = YES;    }    return result;}// ---------------------------------------------------------------------------------//	¥ removeObject// ---------------------------------------------------------------------------------- (void)removeObject:(id)anObject{	[tableArray removeObject:anObject];}// ---------------------------------------------------------------------------------//	¥ removeAllObjects// ---------------------------------------------------------------------------------- (void)removeAllObjects {    [tableArray removeAllObjects];}// ---------------------------------------------------------------------------------//	¥ addObject:// ---------------------------------------------------------------------------------// add an object to the end of the Table data array// return its index;- (int)addObject:(id)entry {    int count;    count = [tableArray count];    [tableArray addObject:entry];    return count;}// ---------------------------------------------------------------------------------//	¥ replaceObjectAtIndex:withObject:// ---------------------------------------------------------------------------------// replace object for specified index// return NO if index is beyond end of array+100- (BOOL)replaceObjectAtIndex:(int)index withObject:(id)anObject {    int count;    BOOL result = NO;    count = [tableArray count];    if (index < count) {        [tableArray replaceObjectAtIndex:index withObject:anObject];        result = YES;    }    else {		if ((index-count) < 100) {  // defensive, don't add more than 100 entries			while (count < index) {				// insert empty entries				[tableArray addObject:kNullObject];				count += 1;			}			[self addObject:anObject];			result = YES;		}    }    return result;}// ---------------------------------------------------------------------------------//	¥ insertObject:atIndex:// ---------------------------------------------------------------------------------// insert object at specified index// return NO if index is beyond end of array+100- (BOOL)insertObject:(id)anObject atIndex:(unsigned)index{    int count;    BOOL result = NO;    count = [tableArray count];    if (index < count) {        [tableArray insertObject:anObject atIndex:index];        result = YES;    }    else {		if ((index-count) < 100) {  // defensive, don't add more than 100 entries			while (count < index) {				// insert empty entries				[tableArray addObject:kNullObject];				count += 1;			}			[tableArray addObject:anObject];			result = YES;		}    }    return result;}// ---------------------------------------------------------------------------------//	¥ indexOfObject// ---------------------------------------------------------------------------------- (unsigned)indexOfObject:(id)anObject{	return [tableArray indexOfObject:anObject];}//==================================================================================#pragma mark -- dictionary access --//==================================================================================// Assumes objects remain sorted in key order.// Only setObject:forKey may be used to add objects.	// entry access// ---------------------------------------------------------------------------------//	¥ objectForKey// ---------------------------------------------------------------------------------// simple binary search for matching object- (id)objectForKey:(id)key{	int count, i;	int low, hi;	NSComparisonResult result;	id object;	id returnValue = nil;		count = [tableArray count];	if (count) {		low = 0;		hi = count - 1;				while (true) {			i = (low + hi)/2;			object = [tableArray objectAtIndex:i];			result = [object compareKey:key];			if (result == NSOrderedSame) {				returnValue = object;				break;			}			else if (result == NSOrderedDescending) {   // key is lower				if (i == low) break;	// not found				hi = i-1;			}			else if (result == NSOrderedAscending) {   // key is higher				if (i == hi) break;   // not found				low = i+1;			}				}	}	return returnValue;}// ---------------------------------------------------------------------------------//	¥ objectForKeyInt// ---------------------------------------------------------------------------------// simple binary search for matching object- (id)objectForKeyInt:(u_int32_t)keyInt{	int count, i;	int low, hi;	NSComparisonResult result;	id object;	id returnValue = nil;		count = [tableArray count];	if (count) {		low = 0;		hi = count - 1;				while (true) {			i = (low + hi)/2;			object = [tableArray objectAtIndex:i];			result = [object compareKeyInt:keyInt];			if (result == NSOrderedSame) {				returnValue = object;				break;			}			else if (result == NSOrderedDescending) {   // key is lower				if (i == low) break;	// not found				hi = i-1;			}			else if (result == NSOrderedAscending) {   // key is higher				if (i == hi) break;   // not found				low = i+1;			}				}	}	return returnValue;}// ---------------------------------------------------------------------------------//	¥ removeObjectForKey// ---------------------------------------------------------------------------------- (void)removeObjectForKey:(id)key{	int count, i;	int low, hi;	NSComparisonResult result;	id object;	id returnValue = nil;		count = [tableArray count];	if (count) {		low = 0;		hi = count - 1;				while (true) {			i = (low + hi)/2;			object = [tableArray objectAtIndex:i];			result = [object compareKey:key];			if (result == NSOrderedSame) {				returnValue = object;				break;			}			else if (result == NSOrderedDescending) {   // key is lower				if (i == low) break;	// not found				hi = i-1;			}			else if (result == NSOrderedAscending) {   // key is higher				if (i == hi) break;   // not found				low = i+1;			}				}		if (returnValue) [tableArray removeObjectAtIndex:i];	}}// ---------------------------------------------------------------------------------//	¥ removeObjectForKeyInt// ---------------------------------------------------------------------------------- (void)removeObjectForKeyInt:(u_int32_t)keyInt{	int count, i;	int low, hi;	NSComparisonResult result;	id object;	id returnValue = nil;		count = [tableArray count];	if (count) {		low = 0;		hi = count - 1;				while (true) {			i = (low + hi)/2;			object = [tableArray objectAtIndex:i];			result = [object compareKeyInt:keyInt];			if (result == NSOrderedSame) {				returnValue = object;				break;			}			else if (result == NSOrderedDescending) {   // key is lower				if (i == low) break;	// not found				hi = i-1;			}			else if (result == NSOrderedAscending) {   // key is higher				if (i == hi) break;   // not found				low = i+1;			}				}		if (returnValue) [tableArray removeObjectAtIndex:i];	}}// ---------------------------------------------------------------------------------//	¥ setObject:forKey// ---------------------------------------------------------------------------------// assumes anObject responds to key- (unsigned)setObject:(id)anObject forKey:(id)key{	int count;	int i = 0;	int low, hi;	NSComparisonResult result;	id object;		count = [tableArray count];	if (count) {		low = 0;		hi = count - 1;				while (true) {			i = (low + hi)/2;			object = [tableArray objectAtIndex:i];			result = [object compareKey:key];			if (result == NSOrderedSame) {				[tableArray replaceObjectAtIndex:i withObject:anObject];				break;			}			else if (result == NSOrderedDescending) {   // key is lower				if (i == low) {					[tableArray insertObject:anObject atIndex:i];					break;	// not found				}				hi = i-1;			}			else if (result == NSOrderedAscending) {   // key is higher				if (i == hi) {					[tableArray insertObject:anObject atIndex:i+1];					break;   // not found				}				low = i+1;			}				}	}	else [tableArray addObject:anObject];	return i;}// ---------------------------------------------------------------------------------//	¥ setObject:forKeyInt// ---------------------------------------------------------------------------------// assumes anObject responds to key- (unsigned)setObject:(id)anObject forKeyInt:(u_int32_t)keyInt{	int count;	int i = 0;	int low, hi;	NSComparisonResult result;	id object;		count = [tableArray count];	if (count) {		low = 0;		hi = count - 1;				while (true) {			i = (low + hi)/2;			object = [tableArray objectAtIndex:i];			result = [object compareKeyInt:keyInt];			if (result == NSOrderedSame) {				[tableArray replaceObjectAtIndex:i withObject:anObject];				break;			}			else if (result == NSOrderedDescending) {   // key is lower				if (i == low) {					[tableArray insertObject:anObject atIndex:i];					break;	// not found				}				hi = i-1;			}			else if (result == NSOrderedAscending) {   // key is higher				if (i == hi) {					[tableArray insertObject:anObject atIndex:i+1];					break;   // not found				}				low = i+1;			}				}	}	else [tableArray addObject:anObject];	return i;}#pragma mark -- data source --// ---------------------------------------------------------------------------------//	¥ numberOfRowsInTableView:// ---------------------------------------------------------------------------------- (int)numberOfRowsInTableView:(NSTableView *)tableView {    return [tableArray count];}// ---------------------------------------------------------------------------------//	¥ tableView:objectValueForTableColumn:row:// ---------------------------------------------------------------------------------- (id)tableView:(NSTableView *)tableView        objectValueForTableColumn:(NSTableColumn *)tableColumn        row:(int)row{	id returnValue;	id entry;	entry = [self objectAtIndex:row];	returnValue = [entry valueForKey:[tableColumn identifier]];	return returnValue;}// ---------------------------------------------------------------------------------//	¥ tableView:setObjectValue:forTableColumn:row:// ---------------------------------------------------------------------------------- (void)tableView:(NSTableView *)tableView setObjectValue:(id)object forTableColumn:(NSTableColumn *)tableColumn row:(NSInteger)row{	id entry;	NSString* columnID;		entry = [self objectAtIndex:row];	columnID = [tableColumn identifier];	[entry setValue:object forKey:columnID];}#pragma mark --- CODING_AND_COPYING ---// <NSCoding>- (void)encodeWithCoder:(NSCoder *)coder{    [coder encodeObject:tableArray];    return;}- (id)initWithCoder:(NSCoder *)coder{    self = [super init];	tableArray = [[coder decodeObject] retain];    return self;}// tell the PortCoder not to use a proxy- (id)replacementObjectForPortCoder:(NSPortCoder *)encoder {    return self;}// <NSCopying>- (id)copyWithZone:(NSZone *)zone {    PSArrayTable *copy;	copy = [[[self class] allocWithZone:zone] init];    [copy setTableArray:tableArray];    return copy;}@end