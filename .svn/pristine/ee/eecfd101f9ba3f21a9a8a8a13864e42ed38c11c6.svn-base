//// kftBridge.c// IPNetRouterX//// Created by Peter Sichel on Tue Jun 24 2004.// Copyright (c) 2004 Sustainable Softworks, Inc. All rights reserved.//// Kernel Bridge Table and support functions//// lastTime is stored as a u_int32_t corresponding to an NSTimeInterval since 1970.#if IPK_NKE#define DEBUG_IPK 0#else#define DEBUG_IPK 0#endif#if DEBUG_IPK#include <sys/syslog.h>#endif#include "IPTypes.h"#include PS_TNKE_INCLUDE#include "kftBridgeTable.h"#include "kft.h"#include "kftSupport.h"#include "IPKSupport.h"#include "FilterTypes.h"#include "avl.h"#include <sys/time.h>#include <netinet/in.h>#include <netinet/tcp.h>#include <netinet/tcp_seq.h>	// sequence number compare macros SEQ_LT, SEQ_LEQ, SEQ_GT, SEQ_GEQ(a,b)#include <sys/socket.h>#include <sys/mbuf.h>#include <net/if.h>#include <net/if_types.h>#if IPK_NKE#include <sys/systm.h>#include <machine/spl.h>#include <sys/param.h>#include <libkern/OSAtomic.h>// define malloc for kernel versus application use#include <sys/malloc.h>#define my_malloc(a)	_MALLOC(a, M_IPFW, M_NOWAIT)#define my_free(a)	FREE(a, M_IPFW)#else#include "stdlib.h"#define my_malloc(a)	malloc(a)#define my_free(a)	free(a)#endif// Global storage//#include "kctGlobal.h"// Module wide storage// allocate Kernel Bridge Tablestatic KFT_bridgeEntry_t bridgeTable[HASH_SIZE+1];static int ageOffset;static int muteCount;//#define kBridgeUpdateBufferSize 2000//static unsigned char updateBuffer[kBridgeUpdateBufferSize];// forward internal function declarations#if !IPK_NKEvoid testMessageFromClient(ipk_message_t* message);#endif// ---------------------------------------------------------------------------------//	¥ KFT_bridgeStart()// ---------------------------------------------------------------------------------//	init bridge table//  Called from IPNetSentry_NKE_start() or SO_KFT_RESET which are thread protectedvoid KFT_bridgeStart(){	// clear bridge table	bzero(bridgeTable, sizeof(KFT_bridgeEntry_t) * HASH_SIZE);	ageOffset = 0;	muteCount = 0;		#if DEBUG_IPK		log(LOG_WARNING, "KFT_bridgeStart\n");	#endif}// ---------------------------------------------------------------------------------//	¥ KFT_bridgeStop()// ---------------------------------------------------------------------------------//	release bridge table//  Called from IPNetSentry_NKE_stop()void KFT_bridgeStop(){	#if DEBUG_IPK		log(LOG_WARNING, "KFT_bridgeStop\n");	#endif}// ---------------------------------------------------------------------------------//	¥ KFT_bridgeFind()// ---------------------------------------------------------------------------------// Search for matching bridge entry in table based on Ethernet address// return a pointer to the found entry (if any)// return value: 0 not foundKFT_bridgeEntry_t* KFT_bridgeFind(EthernetAddress_t*  ea){	int index;	KFT_bridgeEntry_t *returnValue = NULL;  // not found	index = HASH_FN(ea);	if ( EA_MATCH(ea, &bridgeTable[index].ea) ) {		// get current time		struct timeval tv;		#if IPK_NKE		getmicrotime(&tv);		#else		gettimeofday(&tv, NULL);		#endif		// set return entry		returnValue = &bridgeTable[index];		// set last time		returnValue->lastTime = tv.tv_sec;	}	return returnValue;}// ---------------------------------------------------------------------------------//	¥ KFT_bridgeAdd()// ---------------------------------------------------------------------------------// Add bridge table entry for Ethernet address specified// caller must look for existing entry to avoid duplicates and/or check for conflicts// return a pointer to the added entry (if any)// return value: 0 out of memoryKFT_bridgeEntry_t* KFT_bridgeAdd(EthernetAddress_t*  ea){	int index;	KFT_bridgeEntry_t *entry = NULL;		index = HASH_FN(ea);	entry = &bridgeTable[index];		bzero(entry, sizeof(KFT_bridgeEntry_t));	// lastTime	struct timeval tv;	#if IPK_NKE	getmicrotime(&tv);	#else	gettimeofday(&tv, NULL);	#endif	entry->lastTime = tv.tv_sec;	// ignore fractional seconds	// hardware address	memcpy(&entry->ea, ea, 6);		return entry;}// ---------------------------------------------------------------------------------//	¥ KFT_bridgeAddPacket()// ---------------------------------------------------------------------------------// add packet info to bridge table// caller must look for existing entry to avoid duplicates and/or check for conflicts// return a pointer to the added entry (if any)// return value: 0 out of memoryKFT_bridgeEntry_t* KFT_bridgeAddPacket(KFT_packetData_t* packet){	u_int8_t* ha;	int index;	KFT_bridgeEntry_t *entry = NULL;		if (packet->direction == kDirectionOutbound) {		ha = mbuf_data(*packet->mbuf_ptr);	}	else ha = (u_int8_t*)*packet->frame_ptr;		index = HASH_FN(&ha[6]);	entry = &bridgeTable[index];		bzero(entry, sizeof(KFT_bridgeEntry_t));	// record which data link packet arrived on	entry->attachIndex = packet->myAttach->attachIndex;	// lastTime	struct timeval tv;	#if IPK_NKE	getmicrotime(&tv);	#else	gettimeofday(&tv, NULL);	#endif	entry->lastTime = tv.tv_sec;	// ignore fractional seconds	// hardware address	memcpy(&entry->ea, &ha[6], 6);	// flags	if (packet->direction == kDirectionOutbound) entry->flags |= kBridgeFlagOutbound;	else entry->flags &= ~kBridgeFlagOutbound;		return entry;}// ---------------------------------------------------------------------------------//	¥ KFT_bridgeDelete()// ---------------------------------------------------------------------------------// Delete actual bridge entry (does not search for a matching entry)// return 0 for successint KFT_bridgeDelete(KFT_bridgeEntry_t* entry){	int returnValue = 0;	bzero(entry, sizeof(KFT_bridgeEntry_t));	return returnValue;}// ---------------------------------------------------------------------------------//	¥ KFT_bridgeAge()// ---------------------------------------------------------------------------------// Age entries in bridge table// Called from ipk_timeout which is thread protected.int KFT_bridgeAge(){	int i;	int start;	int limit;	KFT_bridgeEntry_t *entry;	u_int8_t bridgeOn = 0;	// check for any bridge enabled interfaces	for (i=1; i<=kMaxAttach; i++) {		if (PROJECT_attach[i].kftInterfaceEntry.bridgeOn) {			bridgeOn = 1;			if (PROJECT_attach[i].muteOn) {				muteCount += 1;				if (muteCount >= 3) {					// turn off mute after 30 seconds					PROJECT_attach[i].muteOn = 0;					muteCount = 0;				}			}	// muteOn				}   // bridgeOn	}	if (bridgeOn) {		// get current time		struct timeval tv;		#if IPK_NKE		getmicrotime(&tv);		#else		gettimeofday(&tv, NULL);		#endif		// setup to age section of table		start = ageOffset;		limit = start + 512;		ageOffset = limit;		if (limit > HASH_SIZE) {			limit = HASH_SIZE;			ageOffset = 0;		}		// loop to age next section		for (i=start; i<=limit; i++) {			entry = &bridgeTable[i];			entry->conflictCount = 0;			// current Time - lastTime			if (tv.tv_sec - entry->lastTime > 240) {  // 4 minutes				//if ( !(entry->flags & kBridgeFlagLocal) )   // skip local ports					KFT_bridgeDelete(entry);			}		}	}	return 0;}