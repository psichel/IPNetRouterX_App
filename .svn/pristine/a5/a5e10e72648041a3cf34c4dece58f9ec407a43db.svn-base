////  PSHistory.m//  IPNetMonitorX////  Created by psichel on Tue Sep 25 2001.//  Copyright (c) 2001 Sustainable Softworks. All rights reserved.////  Encapsulates a History list used as a data source for a Combo Box//  We store the list in three arrays, permanent entries, temporary or//  suggested entries, user history.#import "PSHistory.h"#import "SystemConfiguration.h"@interface PSHistory (PrivateMethods)- (unsigned)count;- (unsigned)historySize;@end@implementation PSHistory//- init and dealloc- (id) init {    if (self = [super init]) {        mFavoriteArray = [[NSMutableArray alloc] init];        mTempArray = [[NSMutableArray alloc] init];        mHistoryArray = [[NSMutableArray alloc] init];		[mHistoryArray addObject:@""];		// zero length separator entry    }    return self;}- (void)clearFavorites {    [mFavoriteArray removeAllObjects];    [mTempArray removeAllObjects];}- (void)clearHistory {	[mHistoryArray removeAllObjects];	[mHistoryArray addObject:@""];		// zero length separator entry}- (void)dealloc {    [mFavoriteArray release];		mFavoriteArray = nil;	[mTempArray release];			mTempArray = nil;	[mHistoryArray release];		mHistoryArray = nil;    [super dealloc];}// ---------------------------------------------------------------------------//	¥ saveWithKey// ---------------------------------------------------------------------------// save to preferences- (void)saveWithKey:(NSString *)key {	// save non temp entries    [preferences setObject:mFavoriteArray forKey:[NSString stringWithFormat:@"%@_favorite",key]];    [preferences setObject:mHistoryArray forKey:key];}// ---------------------------------------------------------------------------//	¥ restoreWithKey// ---------------------------------------------------------------------------// restore from preferences- (void)restoreWithKey:(NSString *)key {	//NSString* attributesKey = [NSString stringWithFormat:@"%@_attributes",key];	int i;    NSMutableArray* theArray;    theArray = [preferences objectForKey:[NSString stringWithFormat:@"%@_favorite",key]];    if (theArray) {        for (i=[theArray count]; i>0; i--) {			[self addFavorite:[theArray objectAtIndex:i-1]];		}    }    theArray = [preferences objectForKey:key];    if (theArray) {        for (i=[theArray count]; i>0; i--) {			[self addHistory:[theArray objectAtIndex:i-1]];		}    }}// ---------------------------------------------------------------------------//	¥ loadDefaultTargets:// ---------------------------------------------------------------------------// add gateway and name server addresses as temporary items in history list- (void)loadDefaultTargets:(int)mask{	// load history with gateway and name server addresses	// x.x.x.x router (en0)	// x.x.x.x name server (en0)	NSArray* interfaceTitles;	NSArray* serviceIDs;	int i, count;	NSString* serviceID = nil;	NSString* addressString;	NSArray* addressList;        	NSString* title;	NSString* localhost = nil;	NSString* localhost6 = nil;	// get port list	interfaceTitles = [[SystemConfiguration sharedInstance] interfaceTitlesAndServiceIDs:&serviceIDs];	[interfaceTitles retain];	[serviceIDs retain];	if (mask & kTargetMaskDNS) {		// find first active service		count = [serviceIDs count];		for (i=0; i<count; i++) {			serviceID = [serviceIDs objectAtIndex:i];			addressString = [[SystemConfiguration sharedInstance] service:serviceID				interfaceDataForKey:@"grantAddress"];			if (![addressString isEqualTo:kSCNotAvailable]) {				if (mask & kTargetMaskLocalhost) {					localhost = [NSString stringWithFormat:@"%@ localhost (%@)",addressString,						bsdNameForTitle([interfaceTitles objectAtIndex:i])];					// check for IPv6 address					addressString = [[SystemConfiguration sharedInstance] service:serviceID						interfaceDataForKey:@"grantAddress6"];					if (![addressString isEqualTo:kSCNotAvailable]) {							localhost6 = [NSString stringWithFormat:@"%@ localhost (%@)",addressString,								bsdNameForTitle([interfaceTitles objectAtIndex:i])];					}				}				break;			}		}		// get name servers		addressList = [[SystemConfiguration sharedInstance]			service:serviceID dataForDictionaryName:@"DNS" key:@"ServerAddresses"];		if (addressList) {			for (i=[addressList count]-1; i>=0; i--) {				title = [NSString stringWithFormat:@"%@ name server",					[addressList objectAtIndex:i]];				[self addTemp:title];			}		}	}	if (mask & kTargetMaskRouter) {		// get router for each port		//for (i=0; i<[serviceIDs count]; i++) {		count = [serviceIDs count];		for (i=count-1; i>=0; i--) {			serviceID = [serviceIDs objectAtIndex:i];			// try to get router			addressString = [[SystemConfiguration sharedInstance]				service:serviceID dataForDictionaryName:@"IPv4" key:@"Router"];			if (addressString) {				title = [NSString stringWithFormat:@"%@ router (%@)",addressString,					bsdNameForTitle([interfaceTitles objectAtIndex:i])];				[self addTemp:title];			}			// IPv6 router			addressString = [[SystemConfiguration sharedInstance]				service:serviceID dataForDictionaryName:@"IPv6" key:@"Router"];			if (addressString) {				title = [NSString stringWithFormat:@"%@ router (%@)",addressString,					bsdNameForTitle([interfaceTitles objectAtIndex:i])];				[self addTemp:title];			}		}	}		if (localhost6) [self addTemp:localhost6];	if (localhost) [self addTemp:localhost];		[serviceIDs release];	[interfaceTitles release];}#pragma mark -- access --// ---------------------------------------------------------------------------//	¥ addHistory:// ---------------------------------------------------------------------------- (void)addHistory:(NSString *)entry {	int i;	if ([entry length]) do {        // check if already a Favorite entry		i = [mFavoriteArray indexOfObject:entry];		if (i != NSNotFound) {			// move to front of Favorites list			[mFavoriteArray removeObjectAtIndex:i];			[mFavoriteArray insertObject:entry atIndex:0];			break;		}        // check if already a Temp entry		i = [mTempArray indexOfObject:entry];		if (i != NSNotFound) {			// move to front of Temp list			[mTempArray removeObjectAtIndex:i];			[mTempArray insertObject:entry atIndex:0];			break;		}        // check if already a History entry		i = [mHistoryArray indexOfObject:entry];		if (i != NSNotFound) {			// move to front of History list			[mHistoryArray removeObjectAtIndex:i];			[mHistoryArray insertObject:entry atIndex:1];   // leave separator			break;		}		// insert object in History list		[mHistoryArray insertObject:entry atIndex:1];		// leave separator		// trim list if needed		unsigned size = [self historySize];		if ([self count] > size) [self removeObjectAtIndex:size];	} while (false);}// ---------------------------------------------------------------------------//	¥ addTemp:// ---------------------------------------------------------------------------- (void)addTemp:(NSString *)entry {	int i;	if ([entry length]) do {        // check if already a Favorite entry		i = [mFavoriteArray indexOfObject:entry];		if (i != NSNotFound) {			// move to front of Favorites list			[mFavoriteArray removeObjectAtIndex:i];			[mFavoriteArray insertObject:entry atIndex:0];			break;		}        // check if already a Temp entry		i = [mTempArray indexOfObject:entry];		if (i != NSNotFound) {			// move to front of Temp list			[mTempArray removeObjectAtIndex:i];			[mTempArray insertObject:entry atIndex:0];			break;		}        // check if already a History entry		i = [mHistoryArray indexOfObject:entry];		if (i != NSNotFound) {			// remove from History list			[mHistoryArray removeObjectAtIndex:i];		}		// insert object in Temp list		[mTempArray insertObject:entry atIndex:0];		// trim list if needed		unsigned size = [self historySize];		if ([self count] > size) [self removeObjectAtIndex:size];	} while (false);}// ---------------------------------------------------------------------------//	¥ addFavorite:// ---------------------------------------------------------------------------- (void)addFavorite:(NSString *)entry {	int i;	if ([entry length]) do {        // check if already a Favorite entry		i = [mFavoriteArray indexOfObject:entry];		if (i != NSNotFound) {			// move to front of Favorites list			[mFavoriteArray removeObjectAtIndex:i];			[mFavoriteArray insertObject:entry atIndex:0];			break;		}        // check if already a Temp entry		i = [mTempArray indexOfObject:entry];		if (i != NSNotFound) {			// remove from Temp list			[mTempArray removeObjectAtIndex:i];		}        // check if already a History entry		i = [mHistoryArray indexOfObject:entry];		if (i != NSNotFound) {			// remove from History list			[mHistoryArray removeObjectAtIndex:i];		}		// insert object in Favorite list		[mFavoriteArray insertObject:entry atIndex:0];		// trim list if needed		unsigned size = [self historySize];		if ([self count] > size) [self removeObjectAtIndex:size];	} while (false);}// ---------------------------------------------------------------------------//	¥ addTempArray// ---------------------------------------------------------------------------- (void)addTempArray:(NSArray *)theArray{    // add from last to first since new objects are inserted at front    int count, i;    count = [theArray count];    for (i=count-1; i>=0; i--) {        [self addTemp:[theArray objectAtIndex:i]];    }}// ---------------------------------------------------------------------------//	¥ removeObject// ---------------------------------------------------------------------------// remove object, return true if any removed- (BOOL)removeObject:(NSString *)inEntry {	BOOL result = NO;	int index;	if ([inEntry length]) do {		index = [mHistoryArray indexOfObject:inEntry];		if (index != NSNotFound) {			[mHistoryArray removeObjectAtIndex:index];			result = YES;			break;		}		index = [mFavoriteArray indexOfObject:inEntry];		if (index != NSNotFound) {			[mFavoriteArray removeObjectAtIndex:index];			result = YES;			break;		}		index = [mTempArray indexOfObject:inEntry];		if (index != NSNotFound) {			[mTempArray removeObjectAtIndex:index];			result = YES;			break;		}    } while (false);	return result;}// ---------------------------------------------------------------------------//	¥ removeObjectAtIndex// ---------------------------------------------------------------------------- (BOOL)removeObjectAtIndex:(int)index{    int favoriteCount, tempCount, historyCount;    BOOL result = NO;    favoriteCount = [mFavoriteArray count];	tempCount = [mTempArray count];	historyCount = [mHistoryArray count];    if (index < favoriteCount) {		// remove entry		[mFavoriteArray removeObjectAtIndex:index];        result = YES;    }	else if (index < (favoriteCount + tempCount)) {		// remove entry		[mTempArray removeObjectAtIndex:index-favoriteCount];        result = YES;	}	else if (index < (favoriteCount + tempCount + historyCount)) {		// remove entry		if (index > (favoriteCount + tempCount) )			[mHistoryArray removeObjectAtIndex:index-(tempCount+favoriteCount)];        result = YES;	}    return result;}// ---------------------------------------------------------------------------//	¥ objectAtIndex// ---------------------------------------------------------------------------// get object value from history array for specified index.// Return nil if row is beyond end of array.- (NSString *)objectAtIndex:(int)index {    int favoriteCount, tempCount, historyCount;    NSString *result=nil;    favoriteCount = [mFavoriteArray count];	tempCount = [mTempArray count];	historyCount = [mHistoryArray count];        if (index < favoriteCount) {		result = [mFavoriteArray objectAtIndex:index];	}	else if (index < (favoriteCount+tempCount)) {		result = [mTempArray objectAtIndex:index-favoriteCount];	}	else if (index < (favoriteCount+tempCount+historyCount)) {		result = [mHistoryArray objectAtIndex:index-(tempCount+favoriteCount)];    }	return result;}// ---------------------------------------------------------------------------//	¥ count// ---------------------------------------------------------------------------- (unsigned)count {    int result;    result = [mFavoriteArray count] + [mTempArray count] + [mHistoryArray count];    return result;}// ---------------------------------------------------------------------------//	¥ historySize// ---------------------------------------------------------------------------- (unsigned)historySize {    int result;    result = [mTempArray count] + kDefaultHistorySize;    return result;}#pragma mark -- dataSource --- (int)numberOfItemsInComboBox:(NSComboBox *)aComboBox {    return [self count];}- (id)comboBox:(NSComboBox *)aComboBox objectValueForItemAtIndex:(int)index {    NSString* entry;    NSString* result = nil;    entry = [self objectAtIndex:index];    if (entry) result = entry;    return result;}- (unsigned int)comboBox:(NSComboBox *)aComboBox indexOfItemWithStringValue:(NSString *)string {    int count, index;    NSString* entry;    // walk the list to find matching object    count = [self count];    for (index=0; index<count; index++) {        entry = [self objectAtIndex:index];        if ([entry isEqualTo:string]) break;    }    return index;}- (NSString *)comboBox:(NSComboBox *)aComboBox completedString:(NSString *)string {    NSString* result=nil;    NSRange r;	// location, length    int count, index, bestL;    NSString* entry;    // walk the list to find longest match    bestL = 0;    count = [self count];    for (index=0; index<count; index++) {        entry = [self objectAtIndex:index];        r = [entry rangeOfString:string options:NSAnchoredSearch];        if (r.length > bestL) {            bestL = r.length;            result = entry;        }    }    return result;}@end